# -*- coding: utf-8 -*-
"""stage2_code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z0qsgOx3uvbBQJCtK6p-47Yty7XYoVFx
"""
# Reproducing a Core Single-Cell RNA-Seq Analysis Pipeline Using Scanpy (Bone Marrow)
# Installation

!pip install scanpy

!pip install anndata

!pip3 install igraph

!pip install celltypist

!pip install decoupler

!pip install fa2-modified

#Import core single cell tools
!pip install crc32c
import scanpy as sc
import anndata as ad

!wget https://github.com/josoga2/sc/raw/refs/heads/main/bone_marrow.h5ad

bone_marrow_df = sc.read('bone_marrow.h5ad')

bone_marrow_df

# check for dimensions of our dataset
bone_marrow_df.shape

#first 5 rows describing the cells ID in our dataset
bone_marrow_df.obs.head()

#first 5 rows describing the genes in our dataset
bone_marrow_df.var.head()

#put both in a proper dataframe format

bone_marrow_df.to_df()

bone_marrow_df.var_names_make_unique()
bone_marrow_df.obs_names_make_unique()

bone_marrow_df.var['MT'] = bone_marrow_df.var_names.str.startswith("MT-")
bone_marrow_df.var['RIBO'] = bone_marrow_df.var_names.str.startswith("RPS", "RPL")
bone_marrow_df.var['HB'] = bone_marrow_df.var_names.str.startswith("^HB[^(P)]")

mt_genes = bone_marrow_df.var[bone_marrow_df.var['MT']]
mt_genes

sc.pp.calculate_qc_metrics(
    bone_marrow_df, qc_vars=["MT", 'RIBO', 'HB'], inplace=True, log1p=True
)

bone_marrow_df.obs.head()

bone_marrow_df.var.head()

sc.pl.violin(
    bone_marrow_df,
    ["n_genes_by_counts"],
    jitter=0.4,
    multi_panel=False,
)

sc.pl.violin(
    bone_marrow_df,
    ["total_counts"],
    jitter=0.4,
    multi_panel=False,
)

sc.pl.violin(
    bone_marrow_df,
    ["pct_counts_MT"],
    jitter=0.4,
    multi_panel=False,
)

#the ribosomal genes
sc.pl.violin(
    bone_marrow_df,
    ["pct_counts_RIBO"],
    jitter=0.4,
    multi_panel=False,
)

#let's visualize the three of them. And let's see where the mitochondrial genes are
sc.pl.scatter(bone_marrow_df, "total_counts", "n_genes_by_counts", color="pct_counts_MT")

sc.pl.scatter(bone_marrow_df, "total_counts", "n_genes_by_counts", color="pct_counts_RIBO")

sc.pl.scatter(bone_marrow_df, "total_counts", "n_genes_by_counts", color="pct_counts_HB")

sc.pp.filter_cells(bone_marrow_df, min_genes=1000)
sc.pp.filter_genes(bone_marrow_df, min_cells=1000)

sc.pl.scatter(bone_marrow_df, "total_counts", "n_genes_by_counts", color="pct_counts_MT")

# we can also further filter for ribosomal contaminations using

bone_marrow_df = bone_marrow_df[
    bone_marrow_df.obs['pct_counts_RIBO'] < 10,
    :
]

sc.pl.scatter(bone_marrow_df, "total_counts", "n_genes_by_counts", color="pct_counts_RIBO")

sc.pp.scrublet(bone_marrow_df)

# Normalization
# Save a copy of the data
bone_marrow_df.layers["counts"] = bone_marrow_df.X.copy()

# Normalizing to median total counts
sc.pp.normalize_total(bone_marrow_df)
# Logarithmize the data
sc.pp.log1p(bone_marrow_df)

# Feature selection
# selecting the top 1000 most variable genes
sc.pp.highly_variable_genes(bone_marrow_df, n_top_genes=1000)

sc.pl.highly_variable_genes(bone_marrow_df)

# Dimensionality Reduction (PCA)
sc.tl.pca(bone_marrow_df)
sc.pl.pca_variance_ratio(bone_marrow_df, n_pcs=10, log=False)

sc.pl.pca(
    bone_marrow_df,
    color=["pct_counts_MT"]
)

sc.pp.neighbors(bone_marrow_df)
sc.tl.umap(bone_marrow_df)

sc.pl.umap(
    bone_marrow_df,
    color=["pct_counts_RIBO"],
    size=8,
)

# Using the igraph implementation and a fixed number of iterations can be significantly faster, especially for larger datasets
sc.tl.leiden(bone_marrow_df, flavor="igraph", n_iterations=2)

sc.pl.umap(
    bone_marrow_df,
    color=["pct_counts_RIBO"],
    size=8,
)

sc.pl.umap(
    bone_marrow_df,
    color=["leiden"],
    size=8,
)

sc.pl.umap(
    bone_marrow_df,
    color=["leiden"],
    # increase horizontal space between panels
    wspace=0.5,
    size=3,
    ncols = 1
)

sc.pl.umap(
    bone_marrow_df,
    color=[ "predicted_doublet"],
    # increase horizontal space between panels
    wspace=0.5,
    size=3,
    ncols = 1
)

sc.pl.umap(
    bone_marrow_df,
    color=[ "doublet_score"],
    # increase horizontal space between panels
    wspace=0.5,
    size=3,
    ncols = 1
)

sc.tl.leiden(bone_marrow_df, flavor="igraph", n_iterations=2, key_added="leiden_res0_02", resolution=0.02)
sc.tl.leiden(bone_marrow_df, flavor="igraph", n_iterations=2, key_added="leiden_res0_5", resolution=0.5)
sc.tl.leiden(bone_marrow_df, flavor="igraph", n_iterations=2, key_added="leiden_res2", resolution=2)

sc.pl.umap(
    bone_marrow_df,
    color=["leiden_res0_02"],
    # increase horizontal space between panels
    wspace=0.5,
    size=15,
    ncols = 1
)

sc.pl.umap(
    bone_marrow_df,
    color=["leiden_res0_5"],
    # increase horizontal space between panels
    wspace=0.5,
    size=15,
    ncols = 1,
    legend_loc="on data"
)

sc.pl.umap(
    bone_marrow_df,
    color=["leiden_res2"],
    # increase horizontal space between panels
    wspace=0.5,
    size=15,
    ncols = 1,
    legend_loc="on data"
)

# Cell Annotation

!wget wget -O result.txt 'http://www.ensembl.org/biomart/martservice?query=<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE Query><Query  virtualSchemaName = "default" formatter = "CSV" header = "0" uniqueRows = "0" count = "" datasetConfigVersion = "0.6" ><Dataset name = "hsapiens_gene_ensembl" interface = "default" ><Attribute name = "ensembl_gene_id" /><Attribute name = "external_gene_name" /></Dataset></Query>'

import pandas as pd

ensembl_var = pd.read_csv('/content/result.txt', header = None)

ensembl_var.columns = ['ensembl_gene_id', 'gene_name']

ensembl_var.head(3)

import decoupler as dc

# Query Omnipath and get PanglaoDB
markers = dc.op.resource(name="PanglaoDB", organism="human")

# Keep canonical cell type markers alone
#markers = markers[markers["canonical_marker"]]

# Remove duplicated entries
markers = markers[~markers.duplicated(["cell_type", "genesymbol"])]

#Format because dc only accepts cell_type and genesymbol

markers = markers.rename(columns={"cell_type": "source", "genesymbol": "target"})
markers = markers[["source", "target"]]


markers.head()

#correct target to ensemble
markers = markers.merge(ensembl_var, left_on="target", right_on="gene_name", how="left")
markers = markers.drop(columns=["target"])
# Remove duplicated entries
markers = markers[~markers.duplicated(["source", "ensembl_gene_id"])]

#Format because dc only accepts cell_type and genesymbol
markers = markers.rename(columns={"source": "source", "ensembl_gene_id": "target"})

markers = markers[["source", "target"]]
markers = markers.dropna()

markers.head()

#load the gene expression matrix into dc

dc.mt.ulm(data=bone_marrow_df,
          net=markers,
          tmin = 3)

#retrieve the score for each cell type

score = dc.pp.get_obsm(bone_marrow_df, key="score_ulm")
score

#preview the data
bone_marrow_df.obsm["score_ulm"].head()

bone_marrow_df.obsm["score_ulm"].columns

sc.pl.umap(score, color=["B cells memory", "leiden_res0_02"], cmap="RdBu_r")

import seaborn as sns

sc.pl.violin(score, keys=["B cells memory"], groupby="leiden_res0_02", rotation=90)

sc.pl.violin(score, keys=["B cells memory"], groupby="leiden_res0_02", rotation=90)

#. Now let's know what each of the 7 clusters mean

bone_marrow_df_rank = dc.tl.rankby_group(score, groupby="leiden_res0_02", reference="rest", method="t-test_overestim_var")
bone_marrow_df_rank = bone_marrow_df_rank[bone_marrow_df_rank["stat"] > 0]
bone_marrow_df_rank.head()

cluster_annotations = bone_marrow_df_rank[bone_marrow_df_rank["stat"] > 0].groupby("group").head(1).set_index("group")["name"].to_dict()
cluster_annotations

bone_marrow_df.obs['cell_type'] = bone_marrow_df.obs['leiden_res0_02'].map(cluster_annotations)

# Example of how to subset for multiple genes in the 'source' column
available_genes = set(bone_marrow_df.var_names)

b_cell_markers = markers[markers['source'].isin(['B cells memory'])]['target']
b_cell_markers = b_cell_markers[b_cell_markers.isin(available_genes)]

nk_cell_markers = markers[markers['source'].isin(['Natural killer T cells'])]['target']
nk_cell_markers = nk_cell_markers[nk_cell_markers.isin(available_genes)]

t_cells_markers = markers[markers['source'].isin(['T cells'])]['target']
t_cells_markers = t_cells_markers[t_cells_markers.isin(available_genes)]


display(b_cell_markers)





